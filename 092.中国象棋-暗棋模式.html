<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./assets/global.css">

    <style>
        .box-a {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .chess-board {
            background-image: url('./assets/chess-piece/chessBoard.png');
            background-repeat: no-repeat;
            width: 100vmin;
            height: 100vmin;
            background-position: center;
            background-size: 90% 90%;
            position: relative;
        }

        .chess-board .cb-grid-box {
            position: absolute;
            display: grid;
            width: 83.2%;
            height: 81.2%;

            left: 5%;
            top: 4%;

            grid-template-columns: repeat(9, 9.7%);
            grid-template-rows: repeat(10, 10%);
            grid-gap: calc(10% / 9) calc(21% / 8);
        }

        .chess-board .cb-grid {
            position: relative;
        }

        .chess-board .cb-grid img {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .chess-board .target-point {
            position: absolute;
            left: 0;
            top: 0;
        }

        .chess-board .cb-over-box {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            background-color: rgba(255, 255, 255, .5);
            padding-bottom: 10vmin;
        }

        .chess-board .hidden {
            display: none;
        }

        .chess-board .over-title {
            font-size: 4vmin;
            font-weight: bold;
            color: #333;
        }

        .chess-board .over-subtitle {
            margin-top: 20px;
            font-size: 5vmin;
            font-weight: bold;
            color: goldenrod;
        }


        .again-btn {
            margin-top: 100px;
            display: inline-flex;
            padding: 0 20px 3px;
            line-height: 40px;
            background: linear-gradient(to bottom, rgb(87, 196, 245), rgb(26, 147, 206));
            color: rgb(254, 252, 255);
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            box-shadow: inset 0px -3px 0 rgb(19, 98, 139);
        }

        .again-btn:active {
            opacity: .7;
            box-shadow: inset 0px 0px 0 transparent;
        }
    </style>
</head>

<body>

    <div class="chess-board">
        <div class="cb-grid-box"></div>
        <div class="cb-over-box hidden">
            <div class="over-title">Ê∏∏ÊàèÁªìÊùü</div>
            <div class="over-subtitle"></div>
            <div class="again-btn">ÂÜçÊù•‰∏ÄÂ±Ä!</div>
        </div>
    </div>

    <script type="module">
        import { Randoms } from "https://gcore.jsdelivr.net/npm/@3r/tool/lib/randoms.js";

        /**
         * ÂàùÂßãÂåñÂπ≥Èù¢Êï∞ÁªÑ
         * @author 	 linyisonger
         * @date 	 2025-01-13
         * 
         * @template T
         * @param {number} rows
         * @param {number} cols
         * @param {T|(x,y)=>T} init 
         * 
         * @return {T[][]}
         */
        function createFlatArray(rows, cols, init = 0) {
            let level1 = []
            for (let y = 0; y < cols; y++) {
                let level2 = [];
                for (let x = 0; x < rows; x++) {
                    level2[x] = typeof init == "function" ? init(x, y) : init;
                }
                level1[y] = level2
            }
            return level1
        }

        class Grid {
            /**
             * @param {number} x
             * @param {number} y
             */
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            /** @type {HTMLDivElement} */
            dom = null
        }


        class TargetPoint extends Grid {
            constructor(x, y) {
                super(x, y)
                let dom = document.createElement('img');
                dom.classList.add('target-point')
                dom.setAttribute('src', './assets/chess-piece/targetPoint.svg')
                chineseChessBoard[y][x].dom.appendChild(dom)
                this.dom = dom;
            }
            /** @type {HTMLImageElement} */
            dom = null
            remove() {
                this.dom.remove()
            }
        }
        // Ê£ãÂ≠êÊ†áÂáÜ
        const CHESS_PIECE_STANDARD = {
            ROOKS: 'ËΩ¶',
            KNIGHTS: 'È©¨',
            ELEPHANTS: 'Áõ∏',
            MANDARINS: 'Â£´',
            KING: 'Â∞Ü',
            CANNONS: "ÁÇÆ",
            PAWMS: 'ÂÖµ'
        }
        const CHESS_PIECE_DARK = {
            DARK: 'Êöó',
        }
        // ÈòµËê•Á±ªÂûã
        const CAMP_TYPE = {
            BLACK: 'Èªë',
            RED: 'Á∫¢'
        }


        class ChessPiece {
            /** Ê£ãÂ≠êÁ±ªÂûã */
            type = null
            /** ÈòµËê•Á±ªÂûã */
            camp = null
        }

        // ‰∏≠ÂõΩË±°Ê£ãÊ£ãÁõò
        let chessBoardGridBox = document.querySelector('.cb-grid-box') // Ê†ºÂ≠êÁõíÂ≠ê
        let chessBoardOverBox = document.querySelector(".cb-over-box") // ÁªìÊùüÁõíÂ≠ê
        let chineseChessBoard = createFlatArray(9, 10, (x, y) => {
            let grid = new Grid(x, y)
            let dom = document.createElement('div')
            dom.classList.add('cb-grid')
            dom.setAttribute('data-x', x)
            dom.setAttribute('data-y', y)
            chessBoardGridBox.appendChild(dom)
            grid.dom = dom;
            grid.dom.addEventListener('click', gridClick)
            return grid;
        })
        /** Ê£ãË∞± @type {ChessPiece[][]} */
        let chessManual = [
            [
                { type: CHESS_PIECE_STANDARD.ROOKS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.KNIGHTS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.ELEPHANTS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.MANDARINS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.KING, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.MANDARINS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.ELEPHANTS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.KNIGHTS, camp: CAMP_TYPE.BLACK },
                { type: CHESS_PIECE_STANDARD.ROOKS, camp: CAMP_TYPE.BLACK },
            ],
            new Array(9).fill(null),
            [
                null,
                { type: CHESS_PIECE_STANDARD.CANNONS, camp: CAMP_TYPE.BLACK },
                null,
                null,
                null,
                null,
                null,
                { type: CHESS_PIECE_STANDARD.CANNONS, camp: CAMP_TYPE.BLACK },
                null,
            ],
            [
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.BLACK },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.BLACK },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.BLACK },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.BLACK },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.BLACK },
            ],
            new Array(9).fill(null),
            new Array(9).fill(null),
            [
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.RED },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.RED },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.RED },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.RED },
                null,
                { type: CHESS_PIECE_STANDARD.PAWMS, camp: CAMP_TYPE.RED },
            ],
            [
                null,
                { type: CHESS_PIECE_STANDARD.CANNONS, camp: CAMP_TYPE.RED },
                null,
                null,
                null,
                null,
                null,
                { type: CHESS_PIECE_STANDARD.CANNONS, camp: CAMP_TYPE.RED },
                null,
            ],
            new Array(9).fill(null),
            [
                { type: CHESS_PIECE_STANDARD.ROOKS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.KNIGHTS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.ELEPHANTS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.MANDARINS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.KING, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.MANDARINS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.ELEPHANTS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.KNIGHTS, camp: CAMP_TYPE.RED },
                { type: CHESS_PIECE_STANDARD.ROOKS, camp: CAMP_TYPE.RED },
            ],
        ]
        /** ÊöóÊ£ã @type {ChessPiece[]} */
        let darkChessPiece = []
        // ÂΩìÂâçÊìç‰ΩúÈòµËê•
        let currentOperateCamp = CAMP_TYPE.RED
        /** @type {ChessPiece} ÂΩìÂâçÊìç‰ΩúÊ£ãÂ≠ê */
        let currentOperateChessPiece = null
        /** @type {Grid} ÂΩìÂâçÊìç‰ΩúÊ†ºÂ≠ê */
        let currentOperateGrid = null
        /** @type {TargetPoint[]} ÂΩìÂâçÊìç‰ΩúÈù∂ÁÇπ */
        let currentTargetPoint = []


        /**
         * Ê†ºÂ≠êÁöÑÁÇπÂáª‰∫ã‰ª∂
         * @author 	 linyisonger
         * @date 	 2025-03-01
         */
        function gridClick() {
            let x = +this.getAttribute('data-x')
            let y = +this.getAttribute('data-y')
            console.log(x, y);
            let grid = chineseChessBoard[y][x];
            let chessPiece = chessManual[y][x];

            if (grid.dom.querySelector('.target-point')) return moveChessPiece(x, y) // ÁßªÂä®Ê£ãÂ≠ê
            if (chessPiece == null) return; // Ê≤°ÊúâÊìç‰ΩúÊ£ãÂ≠ê
            if (chessPiece.camp != currentOperateCamp) return; // ‰∏çËØ•‰Ω†Êìç‰Ωú

            currentOperateChessPiece = chessPiece;
            currentOperateGrid = grid

            generateTargetPoint()
        }

        /**
         * Âä†ËΩΩÊ£ãÁõò 
         */
        function loadChessManual() {
            for (let y = 0; y < chessManual.length; y++) {
                let rows = chessManual[y]
                for (let x = 0; x < rows.length; x++) {
                    const chessPiece = rows[x];
                    if (chessPiece == null) continue
                    const dom = document.createElement('img')
                    dom.classList.add('chess-piece')
                    if (chessPiece.type == CHESS_PIECE_STANDARD.KING) { // ‰∏ªÂ∞Ü‰∏çÂèò
                        dom.setAttribute('src', `./assets/chess-piece/${chessPiece.type}-${chessPiece.camp}.png`)
                    }
                    else { // ÊöóÊ£ã
                        darkChessPiece.push(chessPiece)
                        dom.setAttribute('src', `./assets/chess-piece/${CHESS_PIECE_DARK.DARK}-${chessPiece.camp}.png`)
                        dom.setAttribute('data-type', CHESS_PIECE_DARK.DARK)
                    }
                    chineseChessBoard[y][x].dom.appendChild(dom)
                }
            }
        }

        /**
         * Âêå‰∏ÄÈòµËê•
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function sameCamp(x, y) {
            return chessManual[y][x] && chessManual[y][x].camp == currentOperateCamp
        }

        /**
         * ÊúâÊ£ãÂ≠ê
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function hasChessPiece(x, y) {
            return chessManual?.[y]?.[x]
        }

        /**
         * Âú®Ê£ãÁõòÂÜÖ
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function insideChessBoard(x, y) {
            return chineseChessBoard?.[y]?.[x]
        }

        /**
         * ÊòØÂê¶ËøáÊ≤≥
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function isCrossRiver(y) {
            return y < 5 && currentOperateCamp == CAMP_TYPE.RED || y > 4 && currentOperateCamp == CAMP_TYPE.BLACK
        }

        /**
         * Áî∞Â≠óÊ†ºÂÜÖ
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function insideMatts(x, y) {
            if (currentOperateCamp == CAMP_TYPE.RED) return 2 < x && x < 6 && y > 6
            return 2 < x && x < 6 && y < 3
        }

        /**
         * Ê£ÄÊü•ÁõÆÊ†áÁÇπ
         * @author 	 linyisonger
         * @date 	 2025-03-01
         */
        function checkTargetPoint(x, y) {
            if (!chineseChessBoard[y][x]) return null
            if (chessManual[y][x] && chessManual[y][x].camp == currentOperateCamp) return null;
            return new TargetPoint(x, y)
        }

        /**
         * ÁîüÊàêÈù∂ÁÇπ
         * @author 	 linyisonger
         * @date 	 2025-02-27
         */
        function generateTargetPoint() {
            clearAllTargetPoint(); // ÂÖàÊ∏ÖÈô§ÂÜçÁîüÊàê
            // ÁîüÊàêËá™Ë∫´Èù∂ÁÇπ
            console.log(currentOperateChessPiece, currentOperateGrid);

            switch (currentOperateChessPiece.type) { // Ê£ãÂ≠êÁ±ªÂûã
                case CHESS_PIECE_STANDARD.PAWMS: // ÂÖµ 
                    currentTargetPoint = generateTargetPointByPawms()
                    break;
                case CHESS_PIECE_STANDARD.KNIGHTS: // È©¨
                    currentTargetPoint = generateTargetPointByKnights()
                    break;
                case CHESS_PIECE_STANDARD.ROOKS: // ËΩ¶
                    currentTargetPoint = generateTargetPointByRooks()
                    break;
                case CHESS_PIECE_STANDARD.CANNONS: // ÁÇÆ
                    currentTargetPoint = generateTargetPointByCannons()
                    break;
                case CHESS_PIECE_STANDARD.ELEPHANTS: // Áõ∏
                    currentTargetPoint = generateTargetPointByElephants()
                    break;
                case CHESS_PIECE_STANDARD.MANDARINS: // Â£´
                    currentTargetPoint = generateTargetPointByMandarins()
                    break;
                case CHESS_PIECE_STANDARD.KING: //Â∞Ü
                    currentTargetPoint = generateTargetPointByKing()
                default:
                    break;
            }
        }

        /**
         * ÂÖµ
         * @author 	 linyisonger
         * @date 	 2025-03-01
         */
        function generateTargetPointByPawms() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            let toward = camp == CAMP_TYPE.RED ? -1 : 1 // ÊúùÂêë
            let targetPoint = [{ x: grid.x, y: grid.y + toward }] // ÁõÆÊ†áÁÇπ‰Ωç 
            if (isCrossRiver(grid.y)) targetPoint.push(...[{ x: grid.x + 1, y: grid.y }, { x: grid.x - 1, y: grid.y }]) // Â¢ûÂä†Â∑¶Âè≥ÁßªÂä®
            // Âú®Ê£ãÁõòÂÜÖÈÉ®„ÄÅÈùûÂêåÈòµËê•ÂÖÅËÆ∏ÁßªÂä®
            return targetPoint.filter(t => insideChessBoard(t.x, t.y) && !sameCamp(t.x, t.y)).map(t => new TargetPoint(t.x, t.y))
        }

        /**
         * È©¨
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function generateTargetPointByKnights() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            let targetPoint = [] // ÁõÆÊ†áÁÇπ‰Ωç
            if (!hasChessPiece(grid.x, grid.y + 1)) targetPoint.push(...[{ x: grid.x - 1, y: grid.y + 2 }, { x: grid.x + 1, y: grid.y + 2 }]) // ‰∏ã
            if (!hasChessPiece(grid.x, grid.y - 1)) targetPoint.push(...[{ x: grid.x - 1, y: grid.y - 2 }, { x: grid.x + 1, y: grid.y - 2 }]) // ‰∏ä
            if (!hasChessPiece(grid.x - 1, grid.y)) targetPoint.push(...[{ x: grid.x - 2, y: grid.y + 1 }, { x: grid.x - 2, y: grid.y - 1 }]) // Â∑¶
            if (!hasChessPiece(grid.x + 1, grid.y)) targetPoint.push(...[{ x: grid.x + 2, y: grid.y + 1 }, { x: grid.x + 2, y: grid.y - 1 }]) // Âè≥
            // Âú®Ê£ãÁõòÂÜÖÈÉ®„ÄÅÈùûÂêåÈòµËê•ÂÖÅËÆ∏ÁßªÂä®
            return targetPoint.filter(t => insideChessBoard(t.x, t.y) && !sameCamp(t.x, t.y)).map(t => new TargetPoint(t.x, t.y))
        }

        /**
         * ËΩ¶
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function generateTargetPointByRooks() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            let targetPoint = [] // ÁõÆÊ†áÁÇπ‰Ωç

            for (let x = grid.x - 1; x > -1; x--) { // ÂæÄÂ∑¶
                if (hasChessPiece(x, grid.y)) { // ÊúâÊ£ãÂ≠ê
                    if (!sameCamp(x, grid.y)) targetPoint.push({ x, y: grid.y }) // ÈùûÂêåÈòµËê•
                    break;
                }
                else targetPoint.push({ x, y: grid.y }) // Êó†Ê£ãÂ≠ê
            }
            for (let x = grid.x + 1; x < 9; x++) { // ÂæÄÂè≥
                if (hasChessPiece(x, grid.y)) { // ÊúâÊ£ãÂ≠ê
                    if (!sameCamp(x, grid.y)) targetPoint.push({ x, y: grid.y }) // ÈùûÂêåÈòµËê•
                    break;
                }
                else targetPoint.push({ x, y: grid.y }) // Êó†Ê£ãÂ≠ê
            }

            for (let y = grid.y - 1; y > -1; y--) { // ÂæÄ‰∏ä
                if (hasChessPiece(grid.x, y)) { // ÊúâÊ£ãÂ≠ê
                    if (!sameCamp(grid.x, y)) targetPoint.push({ x: grid.x, y }) // ÈùûÂêåÈòµËê•
                    break;
                }
                else targetPoint.push({ x: grid.x, y }) // Êó†Ê£ãÂ≠ê
            }
            for (let y = grid.y + 1; y < 10; y++) { // ÂæÄ‰∏ã
                if (hasChessPiece(grid.x, y)) { // ÊúâÊ£ãÂ≠ê
                    if (!sameCamp(grid.x, y)) targetPoint.push({ x: grid.x, y }) // ÈùûÂêåÈòµËê•
                    break;
                }
                else targetPoint.push({ x: grid.x, y }) // Êó†Ê£ãÂ≠ê
            }
            return targetPoint.map(t => new TargetPoint(t.x, t.y))
        }

        /**
         * ÁÇÆ
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function generateTargetPointByCannons() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            let targetPoint = [] // ÁõÆÊ†áÁÇπ‰Ωç

            for (let x = grid.x - 1; x > -1; x--) { // ÂæÄÂ∑¶
                if (hasChessPiece(x, grid.y)) { // ÊúâÊ£ãÂ≠ê
                    for (let tx = x - 1; tx > -1; tx--) { // ÁøªÂ±±ÁÇÆ
                        if (hasChessPiece(tx, grid.y) && !sameCamp(tx, grid.y)) { // ÈùûÂêåÈòµËê•
                            targetPoint.push({ x: tx, y: grid.y })
                            break;
                        }
                    }
                    break;
                }
                else targetPoint.push({ x, y: grid.y }) // Êó†Ê£ãÂ≠ê
            }
            for (let x = grid.x + 1; x < 9; x++) { // ÂæÄÂè≥
                if (hasChessPiece(x, grid.y)) { // ÊúâÊ£ãÂ≠ê
                    for (let tx = x + 1; tx < 9; tx++) { // ÁøªÂ±±ÁÇÆ
                        if (hasChessPiece(tx, grid.y) && !sameCamp(tx, grid.y)) { // ÈùûÂêåÈòµËê•
                            targetPoint.push({ x: tx, y: grid.y })
                            break;
                        }
                    }
                    break;
                }
                else targetPoint.push({ x, y: grid.y }) // Êó†Ê£ãÂ≠ê
            }

            for (let y = grid.y - 1; y > -1; y--) { // ÂæÄ‰∏ä
                if (hasChessPiece(grid.x, y)) { // ÊúâÊ£ãÂ≠ê
                    for (let ty = y - 1; ty > -1; ty--) { // ÁøªÂ±±ÁÇÆ
                        if (hasChessPiece(grid.x, ty) && !sameCamp(grid.x, ty)) { // ÈùûÂêåÈòµËê•
                            targetPoint.push({ x: grid.x, y: ty })
                            break;
                        }
                    }
                    break;
                }
                else targetPoint.push({ x: grid.x, y }) // Êó†Ê£ãÂ≠ê
            }
            for (let y = grid.y + 1; y < 10; y++) { // ÂæÄ‰∏ã
                if (hasChessPiece(grid.x, y)) { // ÊúâÊ£ãÂ≠ê
                    for (let ty = y + 1; ty < 10; ty++) { // ÁøªÂ±±ÁÇÆ
                        if (hasChessPiece(grid.x, ty) && !sameCamp(grid.x, ty)) { // ÈùûÂêåÈòµËê•
                            targetPoint.push({ x: grid.x, y: ty })
                            break;
                        }
                    }
                    break;
                }
                else targetPoint.push({ x: grid.x, y }) // Êó†Ê£ãÂ≠ê
            }
            return targetPoint.map(t => new TargetPoint(t.x, t.y))
        }

        /**
         * Áõ∏
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function generateTargetPointByElephants() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            let targetPoint = [] // ÁõÆÊ†áÁÇπ‰Ωç 
            if (!hasChessPiece(grid.x + 1, grid.y + 1)) targetPoint.push({ x: grid.x + 2, y: grid.y + 2 }) // Âè≥‰∏ã
            if (!hasChessPiece(grid.x + 1, grid.y - 1)) targetPoint.push({ x: grid.x + 2, y: grid.y - 2 }) // Âè≥‰∏ä
            if (!hasChessPiece(grid.x - 1, grid.y - 1)) targetPoint.push({ x: grid.x - 2, y: grid.y - 2 }) // Â∑¶‰∏ä
            if (!hasChessPiece(grid.x - 1, grid.y + 1)) targetPoint.push({ x: grid.x - 2, y: grid.y + 2 }) // Â∑¶‰∏ã

            // targetPoint = targetPoint.filter(t => !isCrossRiver(t.y)); // ËøáÊ≤≥Ê£ÄÊµã

            // Âú®Ê£ãÁõòÂÜÖÈÉ®„ÄÅÈùûÂêåÈòµËê•ÂÖÅËÆ∏ÁßªÂä®
            return targetPoint.filter(t => insideChessBoard(t.x, t.y) && !sameCamp(t.x, t.y)).map(t => new TargetPoint(t.x, t.y))
        }


        /**
         * Â£´
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function generateTargetPointByMandarins() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            // ÁõÆÊ†áÁÇπ‰Ωç
            let targetPoint = [
                { x: grid.x + 1, y: grid.y + 1 }, // Âè≥‰∏ã
                { x: grid.x + 1, y: grid.y - 1 }, // Âè≥‰∏ä
                { x: grid.x - 1, y: grid.y + 1 }, // Â∑¶‰∏ã
                { x: grid.x - 1, y: grid.y - 1 }  // Â∑¶‰∏ä
            ]

            // Áî∞Â≠óÊ†ºÊ£ÄÊµã
            targetPoint = isDarkChessPiece(grid.dom) ? targetPoint.filter(t => insideMatts(t.x, t.y)) : targetPoint

            // Âú®Ê£ãÁõòÂÜÖÈÉ®„ÄÅÈùûÂêåÈòµËê•ÂÖÅËÆ∏ÁßªÂä®
            return targetPoint.filter(t => insideChessBoard(t.x, t.y) && !sameCamp(t.x, t.y)).map(t => new TargetPoint(t.x, t.y))
        }

        /**
         * Â∞Ü
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function generateTargetPointByKing() {
            let camp = currentOperateCamp; // ÈòµËê•
            let grid = currentOperateGrid; // ÂΩìÂâçÊ†ºÂ≠ê
            let board = chineseChessBoard; // Ê£ãÁõò
            // ÁõÆÊ†áÁÇπ‰Ωç
            let targetPoint = [
                { x: grid.x + 1, y: grid.y }, // Âè≥ 
                { x: grid.x - 1, y: grid.y }, // Â∑¶
                { x: grid.x, y: grid.y + 1 }, // ‰∏ã
                { x: grid.x, y: grid.y - 1 }  // ‰∏ä
            ]
            // Áî∞Â≠óÊ†ºÊ£ÄÊµã
            targetPoint = targetPoint.filter(t => insideMatts(t.x, t.y))

            // ÂΩì‰∏§Â∞ÜÈù¢ÂØπÈù¢Êó∂ÔºåÂèØ‰ª•Â∞ÜÂØπÈù¢Â∞ÜÊùÄÊéâ
            let toward = camp == CAMP_TYPE.RED ? -1 : 1 // ÂâçËøõÊñπÂêëÊÑü  
            for (let y = grid.y + toward; y > -1; y = y + toward) {
                if (hasChessPiece(grid.x, y)) { // ÊòØÂê¶ÊúâÊ£ãÂ≠ê
                    if (chessManual[y][grid.x].type == CHESS_PIECE_STANDARD.KING) targetPoint.push({ x: grid.x, y }) // Á±ªÂûã‰∏∫Â∞Ü
                    break
                }
            }

            return targetPoint.filter(t => insideChessBoard(t.x, t.y) && !sameCamp(t.x, t.y)).map(t => new TargetPoint(t.x, t.y))
        }


        /**
         * Ê∏ÖÈô§ÊâÄÊúâÁõÆÊ†áÁÇπ
         * @author 	 linyisonger
         * @date 	 2025-02-27
         */
        function clearAllTargetPoint() {
            currentTargetPoint.forEach(t => t.remove()) // Ê∏ÖÁ©∫Èù∂ÁÇπ
            currentTargetPoint = []
        }

        /**
         * ÁßªÂä®Ê£ãÂ≠ê
         * @author 	 linyisonger
         * @date 	 2025-03-01
         */
        function moveChessPiece(x, y) {
            console.log('ÁßªÂä®Ê£ãÂ≠ê', currentOperateChessPiece, currentOperateGrid);
            clearAllTargetPoint();

            let nextOperateGrid = chineseChessBoard[y][x];
            let tempOperateChessPiece = chessManual[y][x];
            let currentChessPieceDom = currentOperateGrid.dom.querySelector('.chess-piece')
            let nextChessPieceDom = nextOperateGrid.dom.querySelector('.chess-piece')

            if (tempOperateChessPiece != null) { // ÂêÉÂ≠ê
                if (isDarkChessPiece(nextOperateGrid.dom)) {
                    tempOperateChessPiece = randomChessPiece()
                }
                console.log('ÂêÉÂ≠ê', tempOperateChessPiece);
                nextChessPieceDom.remove()
                if (tempOperateChessPiece.type == CHESS_PIECE_STANDARD.KING) { // Ë¢´ÂêÉÊéâÁöÑÊòØÂ∞Ü
                    chessBoardOverBox.querySelector('.over-subtitle').textContent = `üéâ${currentOperateCamp}ÊñπËé∑ËÉúÔºÅ`
                    chessBoardOverBox.classList.remove('hidden')
                }
            }


            if (isDarkChessPiece(currentOperateGrid.dom)) {
                currentOperateChessPiece = randomChessPiece()
                console.log('ÊòéÂ≠ê', currentOperateChessPiece);
                currentChessPieceDom.removeAttribute('data-type')
                currentChessPieceDom.setAttribute('src', `./assets/chess-piece/${currentOperateChessPiece.type}-${currentOperateChessPiece.camp}.png`)
            }

            nextOperateGrid.dom.appendChild(currentChessPieceDom)
            chessManual[y][x] = currentOperateChessPiece;
            chessManual[currentOperateGrid.y][currentOperateGrid.x] = null;

            currentOperateCamp = currentOperateCamp === CAMP_TYPE.RED ? CAMP_TYPE.BLACK : CAMP_TYPE.RED // ÂàáÊç¢ÈòµËê•
        }

        /**
         * ÁªìÊùüÈ°µÈù¢
         * @author 	 linyisonger
         * @date 	 2025-03-02
         */
        function loadOverPanel() {
            let againBtn = chessBoardOverBox.querySelector('.again-btn')
            againBtn.addEventListener('click', () => {
                location.reload()
            })
        }

        /**
         * ÈöèÊú∫Ê£ãÂ≠ê
         * @author 	 linyisonger
         * @date 	 2025-03-03
         */
        function randomChessPiece() {
            let idx = Randoms.int(0, darkChessPiece.length)
            return darkChessPiece.splice(idx, 1).shift()
        }

        /**
         * ÊòØÂê¶ÊòØÊöóÊ£ã
         * @author 	 linyisonger
         * @date 	 2025-03-03
         * @param {HTMLImageElement} dom
         */
        function isDarkChessPiece(dom) {
            return dom.querySelector('.chess-piece').getAttribute('data-type') === CHESS_PIECE_DARK.DARK
        }

        loadChessManual();
        loadOverPanel();
    </script>


</body>

</html>